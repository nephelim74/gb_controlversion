<h1 id="справочник-по-командам-git">Справочник по командам GIT.</h1>
<h3 id="git--самая-популярная-в-мире-распределённая-система-контроля-версий-линус-торвальдс-разработчик-ядра-ос-linux-создал-этот-инструмент-ещё-в-2005-году-а-сегодня-git-активно-поддерживается-как-проект-с-открытым-исходным-кодом-огромное-количество-открытых-и-коммерческих-проектов-используют-git-для-контроля-версий">git — самая популярная в мире распределённая система контроля версий. Линус Торвальдс, разработчик ядра ОС Linux, создал этот инструмент ещё в 2005 году, а сегодня Git активно поддерживается как проект с открытым исходным кодом. Огромное количество открытых и коммерческих проектов используют Git для контроля версий.</h3>
<p><img src="images/github.webp" alt=""></p>
<ul>
<li><a href="#как-задать-имя-пользователя">Как задать имя пользователя и адрес электронной почты</a></li>
<li><a href="#кэширование-учётных-данных.">Кэширование учётных данных</a></li>
<li><a href="#инициализация-репозитория.">Инициализация репозитория</a></li>
<li><a href="#добавление-отдельных-файлов-или-всех-файлов-в-область-подготовленных-файлов.">Добавление отдельных файлов или всех файлов в область подготовленных файлов</a></li>
<li><a href="#проверка-статуса-репозитори.">Проверка статуса репозитория</a></li>
<li><a href="#внесение-изменений-однострочным-сообщением-или-через-редактор.">Внесение изменений однострочным сообщением или через редактор</a></li>
<li><a href="#просмотр-истории-коммитов-с-изменениями.">Просмотр истории коммитов с изменениями</a></li>
<li><a href="#просмотр-заданного-коммита.">Просмотр заданного коммита</a></li>
<li><a href="#просмотр-изменений-до-коммита.">Просмотр изменений до коммита</a></li>
<li><a href="#удаление-отслеживаемых-файлов-из-текущего-рабочего-дерева.">Удаление отслеживаемых файлов из текущего рабочего дерева</a></li>
<li><a href="#переименование-файлов.">Переименование файлов</a></li>
<li><a href="#отмена-подготовленных-и-неподготовленных-изменений.">Отмена подготовленных и неподготовленных изменений</a></li>
<li><a href="#изменение-последнего-коммита.">Изменение последнего коммита</a></li>
<li><a href="#откат-последнего-коммита.">Откат последнего коммита</a></li>
<li><a href="#откат-заданного-коммита.">Откат заданного коммита</a></li>
<li><a href="#создание-новой-ветки-и-переход-в-неё.">Создание новой ветки и переход в неё</a></li>
<li><a href="#просмотр-списка-веток.">Просмотр списка веток</a></li>
<li><a href="#удаление-ветки.">Удаление ветки</a></li>
<li><a href="#слияние-двух-веток.">Слияние двух веток</a></li>
<li><a href="#отображение-журнала-фиксации-в-виде-графика-для-текущей-или-всех-веток.">Отображение журнала фиксации в виде графика для текущей или всех веток</a></li>
<li><a href="#прекращение-слияния-при-конфликте.">Прекращение слияния при конфликте</a></li>
<li><a href="#добавление-удалённого-репозитория.">Добавление удалённого репозитория</a></li>
<li><a href="#просмотр-удалённых-URL-адресов.">Просмотр удалённых URL-адресов</a></li>
<li><a href="#получение-дополнительных-сведений-об-удалённом-репозитории.">Получение дополнительных сведений об удалённом репозитории</a></li>
<li><a href="#отправка-изменений-в-удалённый-репозиторий.">Отправка изменений в удалённый репозиторий</a></li>
<li><a href="#получение-изменений-из-удалённого-репозитория.">Получение изменений из удалённого репозитория</a></li>
<li><a href="#слияние-удалённого-репозитория-с-локальным.">Слияние удалённого репозитория с локальным</a></li>
<li><a href="#oтправка-новой-ветки-в-удалённый-репозиторий.">Отправка новой ветки в удалённый репозиторий</a></li>
<li><a href="#удаление-удалённой-ветки.">Удаление удалённой ветки</a></li>
<li><a href="#использование-перебазирования.">Использование перебазирования</a></li>
</ul>
<h2 id="1-как-задать-имя-пользователя-и-адрес-электронной-почты">1. Как задать имя пользователя и адрес электронной почты.</h2>
<p>Имя пользователя нужно, чтобы привязывать коммиты к вашему имени. Это не то же самое, что имя пользователя учётной записи GitHub, с помощью которого выполняется вход в профиль на GitHub. Задать или изменить имя пользователя можно с помощью команды git config. Новое имя будет автоматически отображаться в последующих коммитах, отправленных на GitHub через командную строку. Если хотите скрыть своё реальное имя, можно использовать в качестве имени пользователя Git произвольный набор символов.</p>
<blockquote>
<p>git config --global user.name &quot;Tara Routray&quot;</p>
</blockquote>
<p>Кроме того, командой git config можно изменять адрес электронной почты, привязанный к вашим коммитам Git. Новый адрес электронной почты будет автоматически отображаться во всех дальнейших коммитах, поданных на GitHub через командную строку.</p>
<blockquote>
<p>git config --global user.email &quot;<a href="mailto:&#100;&#101;&#x76;&#x40;&#x74;&#x61;&#x72;&#97;&#114;&#x6f;&#117;&#116;&#x72;&#97;&#121;&#x2e;&#99;&#x6f;&#109;">&#100;&#101;&#x76;&#x40;&#x74;&#x61;&#x72;&#97;&#114;&#x6f;&#117;&#116;&#x72;&#97;&#121;&#x2e;&#99;&#x6f;&#109;</a>&quot;</p>
</blockquote>
<h2 id="2-кэширование-учётных-данных">2. Кэширование учётных данных.</h2>
<p>Кэшировать учётные данные можно с помощью параметра config с флагом --global. Так вы избавитесь от необходимости вручную вводить имя пользователя и пароль при создании нового коммита.</p>
<blockquote>
<p>git config --global credential.helper cache</p>
</blockquote>
<h2 id="3-инициализация-репозитория">3. Инициализация репозитория.</h2>
<p>Создать пустой репозиторий Git или вновь инициализировать существующий можно параметром init. При инициализации он создаст скрытую папку. В ней содержатся все объекты и ссылки, которые Git использует и создаёт в истории работы над проектом.</p>
<blockquote>
<p>git init</p>
</blockquote>
<h2 id="4-добавление-отдельных-файлов-или-всех-файлов-в-область-подготовленных-файлов">4. Добавление отдельных файлов или всех файлов в область подготовленных файлов.</h2>
<p>Добавить отдельный файл в область подготовленных файлов можно параметром add с указанием имени файла. Просто замените somefile.js на актуальное имя.</p>
<blockquote>
<p>git add somefile.js</p>
</blockquote>
<p>Кроме того, можно добавить все файлы и папки в эту область, предоставив wildcard . вместо имени файла:</p>
<blockquote>
<p>git add .</p>
</blockquote>
<h2 id="5-проверка-статуса-репозитория">5. Проверка статуса репозитория.</h2>
<p>Просмотреть статус нужного репозитория можно по ключевому слову status: его действие распространяется на подготовленные, неподготовленные и неотслеживаемые файлы.</p>
<blockquote>
<p>git status</p>
</blockquote>
<h2 id="6-внесение-изменений-однострочным-сообщением-или-через-редактор">6. Внесение изменений однострочным сообщением или через редактор.</h2>
<p>При создании коммита в репозитории можно добавить однострочное сообщение с помощью параметра commit с флагом -m. Само сообщение вводится непосредственно после флага, в кавычках.</p>
<blockquote>
<p>git commit -m &quot;Your short summary about the commit&quot;</p>
</blockquote>
<p>Также можно открыть текстовый редактор в терминале для написания полного сообщения коммита. Оно может состоять из нескольких строк текста, в котором подробно характеризуются изменения, внесённые в репозиторий.</p>
<blockquote>
<p>git commit</p>
</blockquote>
<h2 id="7--просмотр-истории-коммитов-с-изменениями">7.  Просмотр истории коммитов с изменениями.</h2>
<p>Просматривать изменения, внесённые в репозиторий, можно с помощью параметра log. Он отображает список последних коммитов в порядке выполнения. Кроме того, добавив флаг -p, вы можете подробно изучить изменения, внесённые в каждый файл.</p>
<blockquote>
<p>git log -p</p>
</blockquote>
<h2 id="8-просмотр-заданного-коммита">8. Просмотр заданного коммита.</h2>
<p>Просмотреть полный список изменений, внесённых конкретным коммитом, можно с помощью параметра show, указав идентификатор или хеш коммита. Значение хеша уникально для каждого коммита, созданного в вашем репозитории.</p>
<blockquote>
<p>git show 1af17e73721dbe0c40011b82ed4bb1a7dbe3ce29</p>
</blockquote>
<p>Также можно использовать сокращённый хеш.</p>
<blockquote>
<p>git show 1af17e</p>
</blockquote>
<h2 id="9-просмотр-изменений-до-коммита">9. Просмотр изменений до коммита.</h2>
<p>Можно просматривать список изменений, внесённых в репозиторий, используя параметр diff. По умолчанию отображаются только изменения, не подготовленные для фиксации.</p>
<blockquote>
<p>git diff</p>
</blockquote>
<p>Для просмотра подготовленных изменений необходимо добавить флаг --staged.</p>
<blockquote>
<p>git diff --staged</p>
</blockquote>
<p>Также можно указать имя файла как параметр и просмотреть изменения, внесённые только в этот файл.</p>
<blockquote>
<p>git diff somefile.js</p>
</blockquote>
<h2 id="10-удаление-отслеживаемых-файлов-из-текущего-рабочего-дерева">10. Удаление отслеживаемых файлов из текущего рабочего дерева.</h2>
<p>Удалять файлы из текущего рабочего дерева можно с помощью параметра rm. При этом файлы удаляются и из индекса.</p>
<blockquote>
<p>git rm dirname/somefile.js</p>
</blockquote>
<p>Можно также использовать маски файлов (например *.js) для удаления всех файлов, соответствующих критерию.</p>
<blockquote>
<p>git rm dirname/*.html</p>
</blockquote>
<ol start="11">
<li><h3 id="переименование-файлов">Переименование файлов.</h3>
</li>
</ol>
<p>Переименовать файл или папку можно параметром mv. Для него указывается источник source и назначение destination. Источник — реально существующий файл или папка, а назначение — существующая папка.</p>
<blockquote>
<p>git mv dir1/somefile.js dir2</p>
</blockquote>
<p>При выполнении команды файл или папка, указанные как источник, будут перемещены в папку назначения. Индекс будет обновлён соответственно, но изменения нужно записать.</p>
<h2 id="12-отмена-подготовленных-и-неподготовленных-изменений">12. Отмена подготовленных и неподготовленных изменений.</h2>
<p>Восстановить файлы рабочего дерева, не подготовленные к коммиту, можно параметром checkout. Для проведения операции требуется указать путь к файлу. Если путь не указан, параметр git checkout изменит указатель HEAD, чтобы задать указанную ветку как текущую.</p>
<blockquote>
<p>git checkout somefile.js</p>
</blockquote>
<p>Восстановить подготовленный файл рабочего дерева можно параметром reset. Потребуется указать путь к файлу, чтобы убрать его из области подготовленных файлов. При этом не будет производиться откат никаких изменений или модификаций — однако файл перейдёт в категорию не подготовленных к коммиту.</p>
<blockquote>
<p>git reset HEAD somefile.js</p>
</blockquote>
<p>Если нужно выполнить это действие для всех подготовленных файлов, путь к ним указывать не надо.</p>
<blockquote>
<p>git reset HEAD</p>
</blockquote>
<h2 id="13-изменение-последнего-коммита">13. Изменение последнего коммита.</h2>
<p>Внести изменения в последний коммит можно параметром commit с флагом --amend. Например, вы записали изменения, внесённые в ряд файлов, и поняли, что допустили ошибку в сообщении коммита. В этом случае можете воспользоваться указанной командой, чтобы отредактировать сообщение предыдущего коммита, не изменяя его снимок.</p>
<blockquote>
<p>git commit --amend -m &quot;Updated message for the previous commit&quot;</p>
</blockquote>
<p>Также можно вносить изменения в файлы, отправленные ранее. Например, вы изменили несколько файлов в ряде папок и хотите их записать как единый снимок, но забыли добавить в коммит одну из папок. Чтобы исправить такую ошибку, достаточно подготовить для фиксации остальные файлы и папки и создать коммит с флагами --amend и --no-edit.</p>
<blockquote>
<p>git add dir1
git commit
Here you forgot to add dir2 to commit, you can execute the
following command to amend the other files and folders.</p>
</blockquote>
<blockquote>
<p>git add dir2
git commit --amend --no-edit</p>
</blockquote>
<p>Флаг --no-edit позволит внести в коммит поправку без изменения сообщения коммита. В этом случае итоговый коммит заменит неполный, а выглядеть это будет так, как будто мы отправили изменения ко всем файлам в нужных папках как единый снимок.</p>
<p>Внимание! Не изменяйте публичные коммиты.</p>
<p>С помощью amend прекрасно исправляются локальные коммиты, а исправления можно передать в общий репозиторий. Однако изменять коммиты, уже доступные другим пользователям, не следует. Помните, что изменённые коммиты являются совершенно новыми, а предыдущий коммит уже не будет доступен в текущей ветке. Последствия будут такими же, как при отмене изменений публичного снимка.</p>
<h2 id="14-откат-последнего-коммита">14. Откат последнего коммита.</h2>
<p>Откатить последний коммит можно с помощью параметра revert. Создастся новый коммит, содержащий обратные преобразования относительно предыдущего, и добавится к истории текущей ветки.</p>
<blockquote>
<p>git revert HEAD</p>
</blockquote>
<p>▍ Разница между revert и reset</p>
<p>Команда git revert отменяет изменения, записанные только одним коммитом. Она не откатывает проект к более раннему состоянию, удаляя все последующие коммиты, как это делает команда git reset.</p>
<p>У команды revert есть два крупных преимущества по сравнению с reset. Во-первых, она не меняет историю проекта и производит операцию, безопасную для коммитов. Во-вторых, её объектом выступает конкретный коммит, созданный в любой момент истории, а git reset всегда берёт за точку отсчёта текущий коммит. К примеру, если нужно отменить старый коммит с помощью git reset, придётся удалить все коммиты, поданные после целевого, а затем выполнить их повторно. Следовательно, команда git revert — гораздо более удобный и безопасный способ отмены изменений.</p>
<h2 id="15-откат-заданного-коммита">15. Откат заданного коммита.</h2>
<p>Откатить проект до заданного коммита можно с помощью параметра revert и идентификатора коммита. Создастся новый коммит — копия коммита с предоставленным идентификатором — и добавится к истории текущей ветки.</p>
<blockquote>
<p>git revert 1af17e</p>
</blockquote>
<h2 id="16-создание-новой-ветки-и-переход-в-неё">16. Создание новой ветки и переход в неё.</h2>
<p>Создать новую ветку можно с помощью параметра branch, указав имя ветки.</p>
<blockquote>
<p>git branch new_branch_name</p>
</blockquote>
<p>Но Git не переключится на неё автоматически. Для автоматического перехода нужно добавить флаг -b и параметр checkout.</p>
<blockquote>
<p>git checkout -b new_branch_name</p>
</blockquote>
<h2 id="17-просмотр-списка-веток">17. Просмотр списка веток.</h2>
<p>Можно просматривать полный список веток, используя параметр branch. Команда отобразит все ветки, отметит текущую звёздочкой (*) и выделит её цветом.</p>
<blockquote>
<p>git branch</p>
</blockquote>
<p>Также можно вывести список удалённых веток с помощью флага -a.</p>
<blockquote>
<p>git branch -a</p>
</blockquote>
<h2 id="18-удаление-ветки">18. Удаление ветки.</h2>
<p>Удалить ветку можно параметром branch с добавлением флага -d и указанием имени ветки. Если вы завершили работу над веткой и объединили её с основной, можно её удалить без потери истории. Однако, если выполнить команду удаления до слияния — в результате появится сообщение об ошибке. Этот защитный механизм предотвращает потерю доступа к файлам.</p>
<blockquote>
<p>git branch -d existing_branch_name</p>
</blockquote>
<p>Для принудительного удаления ветки используется флаг -D с заглавной буквой. В этом случае ветка будет удалена независимо от текущего статуса, без предупреждений.</p>
<blockquote>
<p>git branch -D existing_branch_name</p>
</blockquote>
<p>Вышеуказанные команды удаляют только локальную копию ветки. В удалённом репозитории она может сохраниться. Если хотите стереть удалённую ветку, выполните следующую команду:</p>
<blockquote>
<p>git push origin --delete existing_branch_name</p>
</blockquote>
<h2 id="19-слияние-двух-веток">19. Слияние двух веток.</h2>
<p>Объединить две ветки можно параметром merge с указанием имени ветки. Команда объединит указанную ветку с основной.</p>
<blockquote>
<p>git merge existing_branch_name</p>
</blockquote>
<p>Если надо выполнить коммит слияния, выполните команду git merge с флагом --no-ff.</p>
<blockquote>
<p>git merge --no-ff existing_branch_name</p>
</blockquote>
<p>Указанная команда объединит заданную ветку с основной и произведёт коммит слияния. Это необходимо для фиксации всех слияний в вашем репозитории.</p>
<h2 id="20-отображение-журнала-фиксации-в-виде-графика-для-текущей-или-всех-веток">20. Отображение журнала фиксации в виде графика для текущей или всех веток.</h2>
<p>Просмотреть историю коммитов в виде графика для текущей ветки можно с помощью параметра log и флагов --graph --oneline --decorate. Опция --graph выведет график в формате ASCII, отражающий структуру ветвления истории коммитов. В связке с флагами --oneline и --decorate, этот флаг упрощает понимание того, к какой ветке относится каждый коммит.</p>
<blockquote>
<p>git log --graph --oneline --decorate</p>
</blockquote>
<p>Для просмотра истории коммитов по всем веткам используется флаг --all.</p>
<blockquote>
<p>git log --all --graph --oneline --decorate</p>
</blockquote>
<h2 id="21-прекращение-слияния-при-конфликте">21. Прекращение слияния при конфликте.</h2>
<p>Прервать слияние в случае конфликта можно параметром merge с флагом --abort. Он позволяет остановить процесс слияния и вернуть состояние, с которого этот процесс был начат.</p>
<blockquote>
<p>git merge --abort</p>
</blockquote>
<p>Также при конфликте слияния можно использовать параметр reset, чтобы восстановить конфликтующие файлы до стабильного состояния.</p>
<blockquote>
<p>git reset</p>
</blockquote>
<h2 id="22-добавление-удалённого-репозитория">22. Добавление удалённого репозитория.</h2>
<p>Добавить удалённый репозиторий можно параметром remote add, указав shortname и url требуемого репозитория.</p>
<blockquote>
<p>git remote add awesomeapp <a href="https://github.com/someurl">https://github.com/someurl</a>..</p>
</blockquote>
<h2 id="23-просмотр-удалённых-url-адресов">23. Просмотр удалённых URL-адресов.</h2>
<p>Просматривать удалённые URL-адреса можно параметром remote с флагом -v. Этот параметр отображает удалённые подключения к другим репозиториям.</p>
<blockquote>
<p>git remote -v</p>
</blockquote>
<p>Такая команда открывает доступ к интерфейсу управления удалёнными записями, которые хранятся в файле .git/config репозитория.</p>
<h2 id="24-получение-дополнительных-сведений-об-удалённом-репозитории">24. Получение дополнительных сведений об удалённом репозитории.</h2>
<p>Получить подробные сведения об удалённом репозитории можно с помощью параметра remote show с указанием имени репозитория — например, origin.</p>
<blockquote>
<p>git remote show origin</p>
</blockquote>
<p>Эта команда отображает список веток, связанных с удалённым репозиторием, а также рабочих станций, подключённых для получения и отправки файлов.</p>
<h2 id="25-отправка-изменений-в-удалённый-репозиторий">25. Отправка изменений в удалённый репозиторий.</h2>
<p>Отправлять изменения в удалённый репозиторий можно параметром push с указанием имени репозитория и ветки.</p>
<blockquote>
<p>git push origin main</p>
</blockquote>
<p>Эта команда передаёт локальные изменения в центральный репозиторий, где с ними могут ознакомиться другие участники проекта.</p>
<h2 id="26-получение-изменений-из-удалённого-репозитория">26. Получение изменений из удалённого репозитория.</h2>
<p>Для загрузки изменений из удалённого репозитория используется параметр pull. Он скачивает копию текущей ветки с указанного удалённого репозитория и объединяет её с локальной копией.</p>
<blockquote>
<p>git pull</p>
</blockquote>
<p>Также можно просмотреть подробные сведения о загруженных файлах с помощью флага --verbose.</p>
<blockquote>
<p>git pull --verbose</p>
</blockquote>
<ol start="27">
<li><h3 id="слияние-удалённого-репозитория-с-локальным">Слияние удалённого репозитория с локальным.</h3>
</li>
</ol>
<p>Слияние удалённого репозитория с локальным выполняется параметром merge с указанием имени удалённого репозитория.</p>
<blockquote>
<p>git merge origin</p>
</blockquote>
<h2 id="28-отправка-новой-ветки-в-удалённый-репозиторий">28. Отправка новой ветки в удалённый репозиторий.</h2>
<p>Передать новую ветку в удалённый репозиторий можно параметром push с флагом -u, указав имя репозитория и имя ветки.</p>
<blockquote>
<p>git push -u origin new_branch</p>
</blockquote>
<h2 id="29-удаление-удалённой-ветки">29. Удаление удалённой ветки.</h2>
<p>Чтобы избавиться от удалённой ветки, используйте параметр push с флагом --delete, указав имя удалённого репозитория и имя ветки.</p>
<blockquote>
<p>git push --delete origin existing_branch</p>
</blockquote>
<h2 id="30-использование-перебазирования">30. Использование перебазирования.##</h2>
<p>Для доступа к этой функции используйте параметр rebase с указанием имени ветки. Перебазирование — это процесс объединения или перемещения последовательности коммитов на новый родительский снимок.</p>
<blockquote>
<p>git rebase branch_name</p>
</blockquote>
<p>Эта команда изменит основу ветки с одного коммита на другой, как если бы вы начали ветку с другого коммита. В Git это достигается за счёт создания новых коммитов и применения их к указанному базовому коммиту. Необходимо понимать, что, хотя ветка и выглядит такой же, она состоит из совершенно новых коммитов.</p>
